# -*- coding: utf-8 -*-
"""strlit_dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KOkIauHL2q2gtwegsFaxF-WG0CAMYZAM
"""

import os
import io
import zipfile
import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import streamlit as st

# ================== CONFIG ==================
DEFAULT_BASE = "/content/drive/MyDrive/artifacts_2stage_hard"
DEFAULT_FILE = "early_warning_test_2023.csv"
MIN_COUNT_DEFAULT = 100
TOP_K_DEFAULT = 20
HIST_BINS_DEFAULT = 50

# ========= MAPPINGS =========
CPV_MAPPING = {
    "03":"Agricultural products","09":"Petroleum products","14":"Mining products","15":"Food products",
    "18":"Clothing / leather","30":"Machinery / equipment","31":"Electrical machinery","33":"Medical equipment",
    "34":"Transport equipment","35":"Security / defence","38":"Lab / measuring","39":"Furniture / supplies",
    "45":"Construction works","50":"Repair / maintenance services","60":"Transport services",
    "70":"Real estate services","71":"Architectural / engineering","72":"IT services",
    "73":"Research / consulting","79":"Education / training","80":"Health / social services",
    "90":"Sewage / refuse / environment","98":"Miscellaneous services",
}
COUNTRY_MAP = {
    "LT":"Lithuania","IT":"Italy","RO":"Romania","ES":"Spain","BG":"Bulgaria","GR":"Greece","PT":"Portugal",
    "PL":"Poland","FR":"France","DE":"Germany","CZ":"Czechia","SK":"Slovakia","HU":"Hungary","NL":"Netherlands",
    "BE":"Belgium","AT":"Austria","IE":"Ireland","DK":"Denmark","SE":"Sweden","FI":"Finland","EE":"Estonia",
    "LV":"Latvia","SI":"Slovenia","HR":"Croatia","LU":"Luxembourg","MT":"Malta","CY":"Cyprus"
}
PROC_MAP = {
    "OPEN":"Open","RESTRICTED":"Restricted",
    "NEGOTIATED_WITH_PUBLICATION":"Negotiated with publication",
    "NEGOTIATED_WITHOUT_PUBLICATION":"Negotiated without publication",
    "COMPETITIVE_DIALOG":"Competitive dialogue",
    "APPROACHING_BIDDERS":"Approaching bidders",
    "INNOVATION_PARTNERSHIP":"Innovation partnership",
}

# ================== CORPORATE THEME ==================
BRAND = {
    "name": "ProcureSight",
    "primary":  "#0B5FFF",
    "secondary":"#1E2A44",
    "accent":   "#00C2A8",
    "bg":       "#F6F8FB",
    "card":     "#FFFFFF",
    "text":     "#121619",
    "muted":    "#5C6B7D"
}
px.defaults.template = "plotly_white"
px.defaults.color_discrete_sequence = [
    BRAND["primary"], BRAND["accent"], "#7A78FF", "#FF7A59", "#2BC255"
]

# ================== HELPERS ==================
def risk_pct(s: pd.Series) -> float:
    return 100.0 * s.astype(bool).mean()

def coerce_bool_col(s: pd.Series) -> pd.Series:
    return s.astype(str).str.lower().isin(["true","1","yes","y","t"])

def safe_numeric(df: pd.DataFrame, cols):
    for c in cols:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors="coerce")
    return df

def derive_labels(df: pd.DataFrame) -> pd.DataFrame:
    if "tender_country" in df.columns:
        df["tender_country"] = df["tender_country"].astype(str).str.strip()

    if "cpv_div2" in df.columns:
        df["cpv_div2_str"] = df["cpv_div2"].astype("Int64").astype(str).str.zfill(2)
        df["cpv_category"] = df["cpv_div2_str"].map(CPV_MAPPING).fillna("Other/Unknown")
    else:
        df["cpv_category"] = "Other/Unknown"

    if "tender_country" in df.columns:
        df["country_name"] = df["tender_country"].map(COUNTRY_MAP).fillna(df["tender_country"])
    else:
        df["country_name"] = "Unknown"

    if "tender_procedureType" in df.columns:
        df["procedure_label"] = df["tender_procedureType"].map(PROC_MAP).fillna(df["tender_procedureType"])
    else:
        df["procedure_label"] = "Unknown"

    if "tender_supplyType" not in df.columns:
        if "cpv_div2" in df.columns:
            div = df["cpv_div2"].fillna(-1).astype(int)
            cond_works = div.eq(45)
            cond_sup = div.between(3, 44)
            cond_serv = (~cond_works) & (~cond_sup) & div.ge(50)
            df["inferred_supplyType"] = np.select(
                [cond_works, cond_sup, cond_serv],
                ["WORKS","SUPPLIES","SERVICES"],
                default="UNKNOWN"
            )
        else:
            df["inferred_supplyType"] = "UNKNOWN"

    if {"cpv_category","cpv_div2"}.issubset(df.columns):
        df["cpv_div2_label"] = df.apply(
            lambda r: f"{r['cpv_category']} (div {int(r['cpv_div2']):02d})"
            if pd.notna(r.get("cpv_div2")) else r["cpv_category"], axis=1
        )
    else:
        df["cpv_div2_label"] = df.get("cpv_category", "Other/Unknown")

    if {"cpv_category","cpv_div2","cpv_grp3"}.issubset(df.columns):
        def _grp_lbl(r):
            d = f"(div {int(r['cpv_div2']):02d})" if pd.notna(r.get("cpv_div2")) else ""
            g = f"grp {int(r['cpv_grp3']):03d}" if pd.notna(r.get("cpv_grp3")) else "grp —"
            return f"{r['cpv_category']} {d} / {g}"
        df["cpv_grp3_label"] = df.apply(_grp_lbl, axis=1)
    else:
        df["cpv_grp3_label"] = df.get("cpv_category", "Other/Unknown")
    return df

def rank_table(df: pd.DataFrame, by_cols, min_count: int) -> pd.DataFrame:
    if isinstance(by_cols, str):
        by_cols = [by_cols]
    out = (
        df.groupby(by_cols, dropna=False)
          .agg(RiskPct=("risk_flag", risk_pct), Count=("risk_flag", "size"))
          .query("Count >= @min_count")
          .sort_values(["RiskPct","Count"], ascending=[False, False])
    )
    return out

def to_csv_download(df: pd.DataFrame, fname: str, label: str):
    csv_bytes = df.to_csv(index=False).encode("utf-8")
    st.download_button(label=label, data=csv_bytes, file_name=fname, mime="text/csv", use_container_width=True)

def plot_risk_vs_count(tbl: pd.DataFrame, title="Risk% & Count (Top-K)", count_in_thousands: bool = True):
    dfp = tbl.reset_index()
    idx_cols = [c for c in dfp.columns if c not in ("RiskPct","Count")]
    x = dfp[idx_cols].astype(str).agg(" — ".join, axis=1)
    risk = dfp["RiskPct"].astype(float)
    cnt  = dfp["Count"].astype(float) / (1000.0 if count_in_thousands else 1.0)

    fig = go.Figure()
    fig.add_trace(go.Bar(
        x=x, y=risk, name="Risk%", yaxis="y1",
        hovertemplate="<b>%{x}</b><br>Risk%: %{y:.2f}%<extra></extra>"
    ))
    fig.add_trace(go.Bar(
        x=x, y=cnt,  name=f"Count{' (K)' if count_in_thousands else ''}", yaxis="y2", opacity=0.6,
        hovertemplate="<b>%{x}</b><br>Count: %{y:,.1f}" + ("K" if count_in_thousands else "") + "<extra></extra>"
    ))
    fig.update_layout(
        title=title,
        xaxis=dict(title="Category"),
        yaxis=dict(title="Risk %", range=[0,100]),
        yaxis2=dict(title=f"Count{' (K)' if count_in_thousands else ''}", overlaying="y", side="right"),
        barmode="group",
        legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
        margin=dict(t=60)
    )
    st.plotly_chart(fig, use_container_width=True)

def build_zip_of_tables(tables: dict, zip_name: str = "summaries.zip") -> bytes:
    bio = io.BytesIO()
    with zipfile.ZipFile(bio, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
        for key, df_tbl in tables.items():
            csv_bytes = df_tbl.reset_index().to_csv(index=False).encode("utf-8")
            zf.writestr(f"{key}.csv", csv_bytes)
    bio.seek(0)
    return bio.read()

def info_banner(msg: str):
    st.markdown(
        f"""
        <div style="
            background: #E8F0FF; border:1px solid #CFE0FF; color:#0B3BAA;
            padding:.75rem 1rem; border-radius:10px; font-size:.95rem;">
            {msg}
        </div>
        """, unsafe_allow_html=True
    )

# ================== UI LAYOUT ==================
st.set_page_config(page_title="Procurement Early Warning Dashboard", layout="wide")

# ---- Global CSS (single block) ----
st.markdown(f"""
<style>
:root {{
  --brand-primary: {BRAND["primary"]};
  --brand-accent:  {BRAND["accent"]};
  --brand-muted:   {BRAND["muted"]};
}}

/* Sidebar labels bold */
section[data-testid="stSidebar"] label,
section[data-testid="stSidebar"] .stMarkdown p {{
  font-weight: 600 !important;
}}

/* Stronger inputs in sidebar */
section[data-testid="stSidebar"] input,
section[data-testid="stSidebar"] textarea,
section[data-testid="stSidebar"] select,
section[data-testid="stSidebar"] .stNumberInput input {{
  border: 2px solid var(--brand-accent) !important;
  background: rgba(0, 194, 168, .08) !important;
  border-radius: 10px !important;
  font-weight: 600 !important;
}}

/* Buttons in sidebar */
section[data-testid="stSidebar"] .stButton > button {{
  border-radius: 12px !important;
  padding: .65rem 1rem !important;
  font-weight: 700 !important;
  background: var(--brand-primary) !important;
  border: 2px solid #ffffff22 !important;
  color: #fff !important;
}}
section[data-testid="stSidebar"] .stButton > button:hover {{
  filter: brightness(1.08);
  transform: translateY(-1px);
}}

/* Number steppers more visible */
section[data-testid="stSidebar"] .stNumberInput button[kind="secondary"],
section[data-testid="stSidebar"] .stNumberInput button[kind="primary"]{{
  border: 1px solid #ffffff44 !important;
  color: #fff !important;
  background: #0b5fff44 !important;
  border-radius: 8px !important;
  font-weight: 700 !important;
}}

/* Small muted text */
.small-muted {{ color: var(--brand-muted); }}
</style>
""", unsafe_allow_html=True)


# ---- Header (logo + title) ----
col_logo, col_title = st.columns([1,8])
with col_logo:
    st.markdown(
        f'<div style="width:64px;height:64px;border-radius:14px;background:{BRAND["primary"]};'
        f'display:flex;align-items:center;justify-content:center;color:white;'
        f'font-weight:700;font-size:22px;">PS</div>', unsafe_allow_html=True
    )
with col_title:
    st.markdown(
        f"<div style='margin-left:.5rem'>"
        f"<h1 style='margin-bottom:.2rem'>Procurement Early Warning Dashboard</h1>"
        f"<div class=\"small-muted\">Interactive monitoring dashboard by {BRAND['name']}</div>"
        f"</div>", unsafe_allow_html=True
    )
st.write("")

# ---- Sidebar (settings + reset) ----
with st.sidebar:
    st.header("Settings")
    base = st.text_input("Base path", value=DEFAULT_BASE)
    default_path = os.path.join(base, DEFAULT_FILE)

    uploaded = st.file_uploader("Upload early_warning CSV", type=["csv"])
    st.caption("Upload a pre-computed early-warning CSV (predicted_days, risk_flag, CPV fields, country).")

    st.divider()
    MIN_COUNT = st.number_input("Minimum count for rankings", 1, 10000, MIN_COUNT_DEFAULT, 10)
    st.caption("Categories with fewer rows than this threshold are excluded from rankings.")

    TOP_K = st.number_input("Top-K bars", 3, 100, TOP_K_DEFAULT, 1)
    st.caption("How many top categories to display in charts.")

    HIST_BINS = st.number_input("Histogram bins (predicted days)", 10, 200, HIST_BINS_DEFAULT, 5)
    st.caption("Number of bins for the predicted duration histogram.")

    st.divider()
    if st.button("Reset filters", type="secondary"):
        for k in ["sel_countries"]:
            st.session_state.pop(k, None)
        if hasattr(st, "cache_data"):
            st.cache_data.clear()
        if hasattr(st, "rerun"):
            st.rerun()
        else:
            st.experimental_rerun()

# ================== LOAD DATA ==================
@st.cache_data(show_spinner=True)
def load_ew_csv(_path: str) -> pd.DataFrame:
    df = pd.read_csv(_path, sep=None, engine="python", encoding_errors="ignore")
    if "risk_flag" in df.columns and df["risk_flag"].dtype != bool:
        df["risk_flag"] = coerce_bool_col(df["risk_flag"])
    df = safe_numeric(df, ["predicted_days","tender_year","cpv_div2","cpv_grp3"])
    df = derive_labels(df)
    for c in ["country_name","cpv_category","procedure_label","cpv_div2_label","cpv_grp3_label"]:
        if c in df.columns:
            df[c] = df[c].astype("category")
    return df

df = None
if uploaded is not None:
    df = pd.read_csv(uploaded, sep=None, engine="python", encoding_errors="ignore")
    if "risk_flag" in df.columns and df["risk_flag"].dtype != bool:
        df["risk_flag"] = coerce_bool_col(df["risk_flag"])
    df = safe_numeric(df, ["predicted_days","tender_year","cpv_div2","cpv_grp3"])
    df = derive_labels(df)
    for c in ["country_name","cpv_category","procedure_label","cpv_div2_label","cpv_grp3_label"]:
        if c in df.columns:
            df[c] = df[c].astype("category")
    info_banner(f"Loaded uploaded file — rows: <b>{len(df):,}</b>")
else:
    if os.path.exists(default_path):
        df = load_ew_csv(default_path)
        info_banner(f"Loaded dataset: <b>{default_path}</b> — rows: <b>{len(df):,}</b>")
    else:
        st.warning("No default file found. Upload a CSV to continue.")

if df is None or df.empty:
    st.stop()

# ================== FILTERS ==================
col1, col2, col3, col4 = st.columns([1.3,1.3,1.3,1])
with col1:
    countries = sorted(df["country_name"].dropna().astype(str).str.strip().unique().tolist()) if "country_name" in df else []
    valid_defaults = [c for c in st.session_state.get("sel_countries", []) if c in countries]
    sel_countries = st.multiselect("Countries", countries, default=valid_defaults)
    st.session_state["sel_countries"] = sel_countries
    st.caption("Only countries present in the loaded dataset are shown.")

with col2:
    cpv_cats = sorted(df["cpv_category"].dropna().unique().tolist()) if "cpv_category" in df else []
    sel_cpv = st.multiselect("CPV categories (Division, 2-digit sectors)", cpv_cats, default=[])
    st.caption("Filter by CPV sector (derived from CPV Division).")

with col3:
    procs = sorted(df["procedure_label"].dropna().unique().tolist()) if "procedure_label" in df else []
    sel_proc = st.multiselect("Procedure types", procs, default=[])
    st.caption("TED procedure types mapped to friendly labels.")

with col4:
    only_risk = st.toggle("High-risk only (≥ 720 days)", value=False)
    st.caption("Show only contracts flagged as long predicted duration.")

# Presets
p1, p2, p3 = st.columns([1,1,1])
with p1:
    apply_supplies = st.button("Preset: Supplies")
with p2:
    apply_services = st.button("Preset: Services")
with p3:
    apply_works = st.button("Preset: Works")
st.caption("Presets use `tender_supplyType` if present; otherwise a CPV-based heuristic (div 45 → Works, 03–44 → Supplies, ≥50 (≠45) → Services).")

preset_mask = pd.Series(True, index=df.index)
if apply_supplies or apply_services or apply_works:
    if "tender_supplyType" in df.columns:
        if apply_supplies: preset_mask &= df["tender_supplyType"].astype(str).str.upper().eq("SUPPLIES")
        if apply_services: preset_mask &= df["tender_supplyType"].astype(str).str.upper().eq("SERVICES")
        if apply_works:    preset_mask &= df["tender_supplyType"].astype(str).str.upper().eq("WORKS")
    elif "inferred_supplyType" in df.columns:
        if apply_supplies: preset_mask &= df["inferred_supplyType"].eq("SUPPLIES")
        if apply_services: preset_mask &= df["inferred_supplyType"].eq("SERVICES")
        if apply_works:    preset_mask &= df["inferred_supplyType"].eq("WORKS")

mask = pd.Series(True, index=df.index)
if sel_countries:
    mask &= df["country_name"].isin(sel_countries)
if sel_cpv:
    mask &= df["cpv_category"].isin(sel_cpv)
if sel_proc:
    mask &= df["procedure_label"].isin(sel_proc)
if only_risk:
    mask &= df["risk_flag"].astype(bool)

df_f = df.loc[mask & preset_mask].copy()
if df_f.empty:
    st.warning("No rows match the current filters. Try relaxing the selections.")
    st.stop()

# ================== KPIs ==================
k1, k2, k3, k4 = st.columns(4)
with k1:
    st.metric("Filtered rows", f"{len(df_f):,}")
with k2:
    rpct = 0.0 if df_f.empty else (100.0 * df_f["risk_flag"].mean())
    st.metric("Risk", f"{rpct:.2f}%")
with k3:
    st.metric("Median predicted days", f"{df_f['predicted_days'].median():.0f}" if "predicted_days" in df_f else "—")
with k4:
    st.metric("Count ≥ 720 days", f"{int(df_f['risk_flag'].sum()):,}")

st.divider()

# ================== PREVIEW & DOWNLOAD ==================
st.subheader("Preview of filtered records")
st.caption("Showing the first rows of the filtered dataset. Use the download to export everything.")
max_rows = int(min(100_000, len(df_f)))
n_show = st.number_input("Rows to display", min_value=10, max_value=max_rows, value=min(200, max_rows), step=100)
show_all = st.checkbox("Show ALL filtered rows (careful with very large tables)", value=False)
st.dataframe(df_f if show_all else df_f.head(int(n_show)), use_container_width=True)
to_csv_download(df_f, "filtered_early_warning.csv", "⬇️ Download filtered CSV")

st.divider()

# ================== RANKINGS & PLOTS ==================
summary_tables = {}

def render_section(title, by_cols, explain=None, rename_cols=None):
    st.markdown(f"### {title}")
    if explain:
        st.caption(explain)
    tbl = rank_table(df_f, by_cols, MIN_COUNT)
    if tbl.empty:
        st.info("No categories meet the minimum count threshold.")
        return

    df_disp = tbl.reset_index()
    if rename_cols: df_disp = df_disp.rename(columns=rename_cols)
    df_disp["RiskPct"] = df_disp["RiskPct"].map(lambda v: f"{v:.2f}%")
    st.dataframe(df_disp.head(100), use_container_width=True)

    summary_tables[tuple(by_cols) if isinstance(by_cols, list) else by_cols] = tbl.copy()
    top_tbl = tbl.head(TOP_K).copy().iloc[::-1]
    plot_risk_vs_count(top_tbl, title=f"Risk% & Count (Top-{TOP_K})")
    to_csv_download(df_disp, f"rank_{'_'.join(by_cols if isinstance(by_cols, list) else [by_cols])}.csv",
                    f"⬇️ Download table: {title}")

# Unified CPV section
render_section(
    title="CPV Sectors & Groups (Division 2-digit, Group 3-digit)",
    by_cols=["cpv_category","cpv_div2","cpv_grp3"],
    explain=(
        "- **CPV Division (2-digit)**: first two digits of the CPV code mapped to a sector name "
        "(e.g., *33* → Medical equipment).\n"
        "- **CPV Group (3-digit)**: first three digits within that division "
        "(e.g., *331* → Medical imaging, radiotherapy, etc.)."
    ),
    rename_cols={"cpv_category":"CPV Category","cpv_div2":"CPV Division","cpv_grp3":"CPV Group"}
)

render_section(
    title="Countries",
    by_cols=["country_name"],
    explain="Country of the tender (mapped from ISO code).",
    rename_cols={"country_name":"Country"}
)

render_section(
    title="Procedure types",
    by_cols=["procedure_label"],
    explain="Standard TED procedure types, displayed with friendly labels.",
    rename_cols={"procedure_label":"Procedure type"}
)

# ZIP with all summaries
if summary_tables:
    zip_bytes = build_zip_of_tables(summary_tables, "summaries.zip")
    st.download_button("⬇️ Download ALL summaries (ZIP)", data=zip_bytes,
                       file_name="summaries.zip", mime="application/zip", use_container_width=True)

st.divider()

# ================== HISTOGRAM ==================
if "predicted_days" in df_f.columns:
    st.markdown("### Distribution of Predicted Duration (days)")
    cuts = pd.cut(df_f["predicted_days"].clip(0, 1800), bins=int(HIST_BINS))
    hist = cuts.value_counts().sort_index()
    labels = [f"[{int(iv.left)}–{int(iv.right)}]" for iv in hist.index.to_list()]
    hist_df = pd.DataFrame({"bin": labels, "count": hist.values}).set_index("bin")
    st.bar_chart(hist_df["count"], use_container_width=True)

# ================== FOOTER ==================
st.markdown(
    """
    <hr style="margin:2rem 0; border-top:1px solid #e6e8ef"/>
    <div style="display:flex;justify-content:space-between;align-items:center;" class="small-muted">
      <div>© ProcurementProject — Early Warning Dashboard</div>
      <div>Contact: <a href="mailto:alarsenoudh@gmail.com">alarsenoudh@gmail.com</a></div>
    </div>
    """,
    unsafe_allow_html=True
)